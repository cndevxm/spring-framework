<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
	   http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"
>
	<!-- AOP的术语
		Aspect 切面：跨多个类的关注点的模块化。事务管理是企业java应用程序中横切关注点的一个很好的例子
			在Spring AOP中切面是基于schema或者注解配置的
		Join point 连接点：程序执行期间的一个点。如方法的执行或者异常的处理，
			在Spring AOP中连接点始终表示方法执行
		Advice 通知：一个切面在一个特定的连接点所采取的行动。不同类型的通知包括“around”、“before”、“after”
			在许多AOP框架（包括Spring）将通知建模成一个拦截器，在连接点周围维护一个拦截器链
		Pointcut 切入点：匹配连接点的谓词。通知和切入点表达式相关联，并在切入点匹配的任何连接点上运行（例如，具有某个名称的方法的执行）
			由切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言
		Introduction 介绍：为一种类型添加额外的方法或者字段，通过引入新的接口已经相应的实现
		Target object 目标对象：被一个或者多个切面通知的对象，也称为被通知对象。由于Spring AOP是通过运行时代理实现的，因此该对象始终是一个代理对象
		AOP proxy AOP代理：AOP框架为了实现切面功能而创建的对象。
		Weaving 编织：将切面与其它应用程序类型或者对象连接起来创建被通知的对象
			AspectJ在编译时编织
			AspectJ5的LTW（Load-Time Weaving）在类加载时编织
			Spring AOP在运行时编织
		Advisor：与切入点表达式关联的通知对象

		通知类型：
			Before advice：在连接点之前执行的通知，不能阻止执行流流向连接点的能力（除非它引发异常）
			After returning advice：在连接点正常完成后通知
			After throwing advice：如果方法通过抛出异常退出，则执行通知
			After（finally） advice：不管连接点以何种方式退出（正常或异常返回），都要执行的通知
			Around advice：围绕连接点的通知。这是最有力的通知，可以在方法调用之前或者之后执行自定义行为，它还可以选择继续连接到连接点或者通过返回自己的返回值或抛出异常的方式来缩短被通知方法的执行

		切入点指示器 PCD：
			execution(方法表达式)：匹配方法签名
			within(类型表达式)：匹配执行引用类型(堆对象)
			this(类型全限定名)：匹配当前连接点代理对象引用为某个特定类型的示例，能够对引入接口进行类型类配
			target(类型全限定名)：匹配当前连接点目标对象引用为某个特定类型的示例，不能对引入接口进行类型匹配
			args(参数类型列表)：匹配当前执行的方法传入的参数为指定类型，必须是类型全限定名，不支持通配符，性能开销大
			@target(注解类型)：匹配连接点所属的目标对象(堆对象)有一个指定的注解，匹配类
			@args(注解列表)：匹配连接点传过来的参数的类型必须有指定的注解，匹配参数
			@within(注解类型)：匹配包含某个注解的类里的所有连接点，只能匹配类
			@annotation(注解类型)：匹配有指定注解的连接点，匹配类或者方法
			bean：spring aop中支持，AspectJ不支持，匹配bean对象名称

		切入点表达式：
			使用“&&”、“||”、“!”进行组合，在schema风格的配置中，使用“and”、“or”、“not”进行替换。
			通配符：
				*：匹配任何字符
				..：匹配任何数量字符
				+；匹配指定类型的子类型，作为后缀放在类型模式后边
			匹配类型：
				注解？	类的全限定名
			匹配方法：
				注解?	修饰符？ 返回值类型	类型声明？	方法名(参数列表)	异常列表？

		坑：
			基于注解的配置通知的执行顺序为：
				未抛出异常：around -> before ->执行业务方法 -> around -> after ->after returning
				抛出异常：around -> before ->执行业务方法 -> around -> after ->after throwing
			基于XML的配置通知的执行顺序为：
				around 与 before 受配置顺序的影响
				after throwing、after returning 与 after 受配置顺序的影响
			同一连接点的多个切面的执行顺序：
				配置order属性，order越小越先执行，遵循先进后出原则
				配置order属性的三种方式：
					1、实现@Ordered接口
					2、使用@Order注解
					3、通过<aop:aspect>标签的order属性

		切入点：
			正则表达式切入点：JdkRegexpMethodPointcut，RegexpMethodPointcutAdvisor
			静态切入点：StaticMethodMatcherPointcut，StaticMethodMatcherPointcutAdvisor
		advice：
			Per-class advice
			Per-instance advice
	-->

	<!-- 服务bean -->
	<bean id="authService" class="com.cndevxm.service.impl.AuthServiceImpl"/>

	<!-- 配置introduction -->
	<bean id="introductionServiceImpl" class="com.cndevxm.aop.IntroductionServiceImpl"/>

	<!-- 提供AspectJ支持 -->
	<aop:aspectj-autoproxy proxy-target-class="true"/>

	<!-- 声明切面bean -->
	<bean id="serviceAspect" class="com.cndevxm.aop.aspects.ServiceAspect"/>

	<!-- aop配置 -->
	<aop:config>
		<!-- 配置切面 -->
		<aop:aspect id="serviceAspect" ref="serviceAspect" order="1">
			<!-- 配置切入点 -->
			<!--			<aop:pointcut id="authPointcut" expression="execution(* com.cndevxm.service.AuthService.login(..))"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="within(com.cndevxm.service..*)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="this(com.cndevxm.service.BaseService)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="target(com.cndevxm.service.BaseService)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="args(java.lang.String)"/>-->

			<!--			<aop:pointcut id="authPointcut" expression="@args(com.cndevxm.aop.annotation.Mark)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="@target(com.cndevxm.aop.annotation.Mark)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="@within(com.cndevxm.aop.annotation.Mark)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="@annotation(com.cndevxm.aop.annotation.Mark)"/>-->

			<aop:pointcut id="authPointcut" expression="bean(authService)"/>

			<!-- 引入接口 必须使用CGLIB -->
			<aop:declare-parents types-matching="com.cndevxm.service.impl.*"
								 implement-interface="com.cndevxm.aop.IntroductionService"
								 delegate-ref="introductionServiceImpl"/>

			<!-- 对引入接口进行匹配，this为代理类能够匹配全部方法，target为目标类只能匹配IntroductionService的方法 -->
			<!--			<aop:pointcut id="authPointcut" expression="this(com.cndevxm.aop.IntroductionService)"/>-->
			<!--			<aop:pointcut id="authPointcut" expression="target(com.cndevxm.aop.IntroductionService)"/>-->

			<aop:around method="doAround" pointcut-ref="authPointcut"/>
			<aop:before method="doBefore" pointcut-ref="authPointcut"/>
			<aop:after-throwing method="doAfterThrowing" pointcut-ref="authPointcut"/>
			<aop:after-returning method="doAfterReturning" pointcut-ref="authPointcut"/>
			<aop:after method="doAfter" pointcut-ref="authPointcut"/>

		</aop:aspect>
	</aop:config>

	<!-- 自定义advice -->
	<bean id="authServiceBeforAdvice" class="com.cndevxm.aop.AuthServiceBeforAdvice"/>
	<!-- 自定义interceptor -->
	<bean id="authServiceInterceptor" class="com.cndevxm.aop.AuthServiceInterceptor"/>
	<!-- 通过ProxyFactoryBean 创建代理对象 -->
	<bean id="proxyAuthService" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="proxyTargetClass" value="true"/>
		<property name="proxyInterfaces" value="com.cndevxm.service.AuthService"/>
		<property name="target">
			<bean class="com.cndevxm.service.impl.AuthServiceImpl"/>
		</property>
		<property name="interceptorNames">
			<list>
				<!-- 此处配置可使用通配符 -->
				<value>authServiceBeforAdvice</value>
				<value>authServiceInterceptor</value>
			</list>
		</property>
	</bean>

	<bean id="autoProxyAuthService" class="com.cndevxm.service.impl.AuthServiceImpl"/>
	<!-- 自动代理创建 -->
	<bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
		<property name="beanNames">
			<list>
				<value>autoProxyAuthService</value>
			</list>
		</property>
		<property name="interceptorNames">
			<list>
				<value>authServiceBeforAdvice</value>
				<value>authServiceInterceptor</value>
			</list>
		</property>
	</bean>


</beans>